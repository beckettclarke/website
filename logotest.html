<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D SVG Logo</title>
  <style>
    body {
      margin: 0;
      background: rgb(16, 16, 16); /* webpage background */
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
  <!-- Import maps for Three.js -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { SVGLoader } from "three/addons/loaders/SVGLoader.js";

    // Scene + Camera + Renderer
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 150);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0); // transparent background
    document.body.appendChild(renderer.domElement);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(0, 1, 1);
    scene.add(dirLight);

    // Custom reflection texture (equirectangular image)
    const texture = new THREE.TextureLoader().load("https://threejs.org/examples/textures/2294472375_24a3b8ef46_o.jpg");
    texture.mapping = THREE.EquirectangularReflectionMapping;

    const material = new THREE.MeshPhysicalMaterial({
      color: 0xedfff5,      // base colour
      metalness: 1,
      roughness: 0.2,
      envMap: texture,
      envMapIntensity: 1.2
    });

    // Load SVG and extrude
    const loader = new SVGLoader();
    loader.load("icons/logo.svg", (data) => {
      const group = new THREE.Group();

      data.paths.forEach((path) => {
        const shapes = SVGLoader.createShapes(path);
        shapes.forEach((shape) => {
          const geometry = new THREE.ExtrudeGeometry(shape, {
            depth: 5,
            bevelEnabled: true,
            bevelThickness: 1,
            bevelSize: 1,
            bevelSegments: 10
          });

          const mesh = new THREE.Mesh(geometry, material);
          mesh.rotation.x = Math.PI; // flip upright
          group.add(mesh);
        });
      });

      // Center the whole group
      const box = new THREE.Box3().setFromObject(group);
      const center = new THREE.Vector3();
      box.getCenter(center);
      group.position.sub(center);

      scene.add(group);
    });

    // --- Rotation setup ---
    const baseRotationX = 0;            // constant tilt around X
    const baseRotationY = 0;            // constant tilt around Y
    const baseRotationZ = Math.PI / 15;  // constant tilt around Z (45°)

    let targetRotationY = 0; // horizontal
    let targetRotationX = 0; // vertical
    let currentRotationY = 0;
    let currentRotationX = 0;

    let lastMouseMove = Date.now();

    document.addEventListener("mousemove", (e) => {
      const x = e.clientX / window.innerWidth;
      const y = e.clientY / window.innerHeight;

      targetRotationY = (x - 0.5) * Math.PI / 3;       // horizontal: -60° to +60°
      targetRotationX = (y - 0.5) * Math.PI / 9;       // vertical: -20° to +20°
      lastMouseMove = Date.now();
    });

    // Render loop with easing
    function animate() {
      requestAnimationFrame(animate);

      const ease = 0.05; // smoothing speed

      // If idle for >1s, drift back to center
      if (Date.now() - lastMouseMove > 1000) {
        targetRotationX = 0;
        targetRotationY = 0;
      }

      currentRotationY += (targetRotationY - currentRotationY) * ease;
      currentRotationX += (targetRotationX - currentRotationX) * ease;

      scene.rotation.y = baseRotationY + currentRotationY;
      scene.rotation.x = baseRotationX + currentRotationX;
      scene.rotation.z = baseRotationZ; // fixed Z rotation

      renderer.render(scene, camera);
    }
    animate();

    // Handle resize
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>